# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _bj_core
else:
    import _bj_core

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def N_e(gamma: "double") -> "double":
    return _bj_core.N_e(gamma)

def description() -> "void":
    return _bj_core.description()

def run_models() -> "int":
    return _bj_core.run_models()

def load_params(name: "char *") -> "int":
    return _bj_core.load_params(name)

def load_params_from_list(list: "char **", model_type: "int", starting_index: "int", list_length: "int") -> "int":
    return _bj_core.load_params_from_list(list, model_type, starting_index, list_length)

def main_swig(allparams: "char *", model_type: "int", directory: "char *", pref: "char *") -> "double *":
    return _bj_core.main_swig(allparams, model_type, directory, pref)

def Simpson(func: "double []", ics: "double []", res: "int", start: "int", end: "int") -> "double":
    return _bj_core.Simpson(func, ics, res, start, end)

def linint(x: "double", xvec: "double []", xdim: "int", x_min: "double", x_max: "double") -> "double":
    return _bj_core.linint(x, xvec, xdim, x_min, x_max)

def j_syn(elec_spec: "double (*)(double)", gamma_min: "double", gamma_max: "double", nu: "double", B: "double", prec1: "int", prec2: "int") -> "double":
    return _bj_core.j_syn(elec_spec, gamma_min, gamma_max, nu, B, prec1, prec2)

def k_esa(elec_spec: "double (*)(double)", gamma_min: "double", gamma_max: "double", nu: "double", B: "double", prec1: "int", prec2: "int") -> "double":
    return _bj_core.k_esa(elec_spec, gamma_min, gamma_max, nu, B, prec1, prec2)

def CylTransfEquat(I_inp: "double", jj: "double", kk: "double", ll: "double") -> "double":
    return _bj_core.CylTransfEquat(I_inp, jj, kk, ll)

def SphTransfEquat(jj: "double", kk: "double", ll: "double") -> "double":
    return _bj_core.SphTransfEquat(jj, kk, ll)

def Intens2Flux(Intens: "double", Radius: "double", Doppler: "double", z: "double", Hubble: "double") -> "double":
    return _bj_core.Intens2Flux(Intens, Radius, Doppler, z, Hubble)

def CylIntens2Flux(Intens1: "double", Intens2: "double", Radius: "double", Length: "double", Doppler: "double", z: "double", Hubble: "double", Theta: "double") -> "double":
    return _bj_core.CylIntens2Flux(Intens1, Intens2, Radius, Length, Doppler, z, Hubble, Theta)

def RingIntens2Flux(Intens: "double", InnRadius: "double", OutRadius: "double", Doppler: "double", z: "double", Hubble: "double", check: "int") -> "double":
    return _bj_core.RingIntens2Flux(Intens, InnRadius, OutRadius, Doppler, z, Hubble, check)

def FreqTransS2O(nu: "double", Doppler: "double", z: "double") -> "double":
    return _bj_core.FreqTransS2O(nu, Doppler, z)

def FreqTransO2S(nu: "double", Doppler: "double", z: "double") -> "double":
    return _bj_core.FreqTransO2S(nu, Doppler, z)

def j_com(elec_spec: "double (*)(double)", gamma_min: "double", gamma_max: "double", I_rad: "double []", nu_rad_min: "double", nu_rad_max: "double", nu_rad_dim: "int", nu: "double", prec1: "int", prec2: "int") -> "double":
    return _bj_core.j_com(elec_spec, gamma_min, gamma_max, I_rad, nu_rad_min, nu_rad_max, nu_rad_dim, nu, prec1, prec2)

def tau_IRA_Kneiske(nu: "double", zz: "double", range: "int") -> "double":
    return _bj_core.tau_IRA_Kneiske(nu, zz, range)

def tau_IRA_Franceschini(nu: "double", zz: "double") -> "double":
    return _bj_core.tau_IRA_Franceschini(nu, zz)

def tau_IRA_Finke(nu: "double", zz: "double") -> "double":
    return _bj_core.tau_IRA_Finke(nu, zz)

def tau_IRA_Franceschini17(nu: "double", zz: "double") -> "double":
    return _bj_core.tau_IRA_Franceschini17(nu, zz)

def tau_IIR(nu: "double", z: "double", level: "int") -> "double":
    return _bj_core.tau_IIR(nu, z, level)

def gg_abs(nu_c: "double", I_syn: "double []", nu_dim: "int", nu_min: "double", nu_max: "double", prec1: "int", prec2: "int") -> "double":
    return _bj_core.gg_abs(nu_c, I_syn, nu_dim, nu_min, nu_max, prec1, prec2)

def sigma_gg(nu_s: "double", nu_c: "double") -> "double":
    return _bj_core.sigma_gg(nu_s, nu_c)

def intgl(func: "double (*)(double)", a: "double", b: "double", n: "int", m: "int") -> "double":
    return _bj_core.intgl(func, a, b, n, m)

def Planck(nu_BB: "double", T_BB: "double") -> "double":
    return _bj_core.Planck(nu_BB, T_BB)

def Distance_Luminosity(z: "double", H0: "double", WM: "double") -> "double":
    return _bj_core.Distance_Luminosity(z, H0, WM)

def piondecay(energy: "double") -> "double":
    return _bj_core.piondecay(energy)

def piondecaytest(energy: "double") -> "double":
    return _bj_core.piondecaytest(energy)

def setHadronicParameters() -> "void":
    return _bj_core.setHadronicParameters()

def setHadronicParametersTest() -> "void":
    return _bj_core.setHadronicParametersTest()

def piondecay_ahaprecise_electron(energy: "double") -> "double":
    return _bj_core.piondecay_ahaprecise_electron(energy)

def new_doubleP() -> "double *":
    return _bj_core.new_doubleP()

def copy_doubleP(value: "double") -> "double *":
    return _bj_core.copy_doubleP(value)

def delete_doubleP(obj: "double *") -> "void":
    return _bj_core.delete_doubleP(obj)

def doubleP_assign(obj: "double *", value: "double") -> "void":
    return _bj_core.doubleP_assign(obj, value)

def doubleP_value(obj: "double *") -> "double":
    return _bj_core.doubleP_value(obj)
class doubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _bj_core.doubleArray_swiginit(self, _bj_core.new_doubleArray(nelements))
    __swig_destroy__ = _bj_core.delete_doubleArray

    def __getitem__(self, index: "size_t") -> "double":
        return _bj_core.doubleArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "double") -> "void":
        return _bj_core.doubleArray___setitem__(self, index, value)

    def cast(self) -> "double *":
        return _bj_core.doubleArray_cast(self)

    @staticmethod
    def frompointer(t: "double *") -> "doubleArray *":
        return _bj_core.doubleArray_frompointer(t)

# Register doubleArray in _bj_core:
_bj_core.doubleArray_swigregister(doubleArray)
cvar = _bj_core.cvar
DEBUG = cvar.DEBUG
q0 = cvar.q0
pc = cvar.pc
H0SI = cvar.H0SI
H0 = cvar.H0
sig_T = cvar.sig_T
m_e = cvar.m_e
c = cvar.c
h = cvar.h
sig = cvar.sig
m_p = cvar.m_p
e = cvar.e
keV = cvar.keV
G = cvar.G
k_B = cvar.k_B
M_sol = cvar.M_sol
eV_K = cvar.eV_K
hour = cvar.hour
day = cvar.day
PLANCK = cvar.PLANCK
eV = cvar.eV
PARSEC = cvar.PARSEC
ERG = cvar.ERG
MELEC = cvar.MELEC
HZ_PER_EV = cvar.HZ_PER_EV
LIGHTSPEED = cvar.LIGHTSPEED
SIGMAT = cvar.SIGMAT
HMASS = cvar.HMASS
MSOL = cvar.MSOL
ALPHA = cvar.ALPHA
MILLIBARN = cvar.MILLIBARN
CHARGE = cvar.CHARGE
MELECKG = cvar.MELECKG
MPION = cvar.MPION
MPROTON = cvar.MPROTON
SYN_PREC1 = cvar.SYN_PREC1
SYN_PREC2 = cvar.SYN_PREC2
ABS_PREC1 = cvar.ABS_PREC1
ABS_PREC2 = cvar.ABS_PREC2
COM_PREC1 = cvar.COM_PREC1
COM_PREC2 = cvar.COM_PREC2
G_MAX = cvar.G_MAX
NU_MAX = cvar.NU_MAX
G_DIM = cvar.G_DIM
N_MIN = cvar.N_MIN
N_MAX = cvar.N_MAX
NU_DIM_MAX = cvar.NU_DIM_MAX
SL_DIM_MAX = cvar.SL_DIM_MAX
n_B = cvar.n_B

def doubleArray_frompointer(t: "double *") -> "doubleArray *":
    return _bj_core.doubleArray_frompointer(t)



